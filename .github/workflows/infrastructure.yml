name: Manage Infrastructure

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy

env:
  TF_VERSION: '1.7.0'

jobs:
  terraform:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ vars.AWS_REGION || 'ap-northeast-1' }}

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Terraform Validate
      if: github.event.inputs.action != 'destroy'
      run: |
        cd terraform
        terraform validate

    - name: Terraform Plan
      id: plan
      run: |
        cd terraform
        echo "Running terraform plan..."
        terraform plan -out=tfplan -detailed-exitcode
      continue-on-error: true
      env:
        TF_IN_AUTOMATION: true

    - name: Terraform Plan Status
      if: steps.plan.outcome == 'failure'
      run: exit 1

    - name: Terraform Apply
      if: github.event.inputs.action == 'apply'
      run: |
        cd terraform
        terraform apply -auto-approve tfplan
      env:
        TF_IN_AUTOMATION: true

    - name: Terraform Destroy
      if: github.event.inputs.action == 'destroy'
      run: |
        cd terraform
        echo "üóëÔ∏è Destroying infrastructure..."
        echo "Checking Terraform state..."
        if [ -f terraform.tfstate ]; then
          echo "State file exists, refreshing state..."
          terraform refresh || echo "State refresh completed with warnings"
          echo "Listing current resources in state..."
          terraform state list || echo "No resources in state"
        else
          echo "‚ö†Ô∏è No state file found - resources may need manual cleanup"
        fi
        terraform destroy -auto-approve

        # Manual cleanup if Terraform state is missing
        echo "Performing manual cleanup of AWS resources..."

        # Delete Route53 DNS record
        echo "Deleting Route53 DNS record..."
        aws route53 list-hosted-zones --query "HostedZones[?Name=='dev-maestra.vottia.me.'].Id" --output text | while read ZONE_ID; do
          if [ ! -z "$ZONE_ID" ]; then
            RECORD_EXISTS=$(aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID --query "ResourceRecordSets[?Name=='test.dev-maestra.vottia.me.' && Type=='A']" --output text)
            if [ ! -z "$RECORD_EXISTS" ]; then
              IP_ADDRESS=$(aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID --query "ResourceRecordSets[?Name=='test.dev-maestra.vottia.me.' && Type=='A'].ResourceRecords[0].Value" --output text)
              aws route53 change-resource-record-sets --hosted-zone-id $ZONE_ID --change-batch "{\"Changes\":[{\"Action\":\"DELETE\",\"ResourceRecordSet\":{\"Name\":\"test.dev-maestra.vottia.me\",\"Type\":\"A\",\"TTL\":300,\"ResourceRecords\":[{\"Value\":\"$IP_ADDRESS\"}]}}]}" || echo "DNS record already deleted or not found"
              echo "DNS record deleted"
            fi
          fi
        done

        # Detach static IP
        echo "Detaching static IP..."
        aws lightsail detach-static-ip --static-ip-name dev-mastra-test-static-ip || echo "Static IP already detached or not found"

        # Delete Lightsail instance
        echo "Deleting Lightsail instance..."
        aws lightsail delete-instance --instance-name dev-mastra-test-instance || echo "Instance already deleted or not found"

        # Delete static IP
        echo "Deleting static IP..."
        aws lightsail release-static-ip --static-ip-name dev-mastra-test-static-ip || echo "Static IP already deleted or not found"

        # Delete key pair
        echo "Deleting key pair..."
        aws lightsail delete-key-pair --key-pair-name dev-mastra-test-key || echo "Key pair already deleted or not found"

        echo "‚úÖ Infrastructure destroyed"
      env:
        TF_IN_AUTOMATION: true

    - name: Wait and verify services
      if: github.event.inputs.action == 'apply'
      run: |
        cd terraform

        # Get connection details
        INSTANCE_IP=$(terraform output -raw instance_public_ip)
        SSH_KEY=$(terraform output -raw ssh_private_key)

        # Setup SSH
        mkdir -p ~/.ssh
        echo "$SSH_KEY" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H $INSTANCE_IP >> ~/.ssh/known_hosts

        echo "Waiting for instance setup to complete..."
        echo "This process typically takes 3-5 minutes for full service initialization."

        # Wait for SSH to be available first
        echo "Waiting for SSH access to be available..."
        SSH_READY=false
        for i in {1..10}; do
          echo "Attempt $i/10: Testing SSH connectivity..."
          if ssh -o ConnectTimeout=10 -o BatchMode=yes -o StrictHostKeyChecking=no ec2-user@$INSTANCE_IP "echo 'SSH connected'" 2>/dev/null; then
            echo "‚úÖ SSH connection established!"
            SSH_READY=true
            break
          else
            echo "‚è≥ SSH not ready, waiting 30 seconds..."
            sleep 30
          fi
        done

        if [ "$SSH_READY" = false ]; then
          echo "‚ùå SSH connection failed after 5 minutes"
          echo "Possible issues:"
          echo "- Instance still booting"
          echo "- Security group blocking SSH"
          echo "- SSH key mismatch"
          echo "- Instance not ready"
          exit 1
        fi

        # Wait for setup completion marker
        echo "Checking for setup completion marker..."
        SETUP_COMPLETE=false
        for i in {1..20}; do
          echo "Attempt $i/20: Checking setup status..."
          if ssh -o ConnectTimeout=10 -o BatchMode=yes -o StrictHostKeyChecking=no ec2-user@$INSTANCE_IP "test -f /home/ec2-user/.setup-completed" 2>/dev/null; then
            echo "‚úÖ Setup completion marker found!"
            SETUP_COMPLETE=true
            break
          else
            echo "‚è≥ Setup still in progress, waiting 30 seconds..."
            sleep 30
          fi
        done

        if [ "$SETUP_COMPLETE" = false ]; then
          echo "‚ö†Ô∏è Setup completion marker not found after 10 minutes"
          echo "Proceeding with service verification anyway..."
        fi

        # Additional wait for services to fully initialize
        echo "Waiting additional 60 seconds for services to fully initialize..."
        sleep 60

        # Verify services are running with retry logic
        ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ec2-user@$INSTANCE_IP << 'EOF'
          # Function to check service with retries
          check_service_with_retry() {
            local service_name=$1
            local check_command=$2
            local max_attempts=5
            local wait_time=10

            for attempt in $(seq 1 $max_attempts); do
              echo "Attempt $attempt/$max_attempts: Checking $service_name..."
              if eval "$check_command"; then
                echo "‚úÖ $service_name is ready"
                return 0
              else
                if [ $attempt -lt $max_attempts ]; then
                  echo "‚è≥ $service_name not ready, waiting ${wait_time}s..."
                  sleep $wait_time
                else
                  echo "‚ùå $service_name failed after $max_attempts attempts"
                  return 1
                fi
              fi
            done
          }

          # Check Docker service with retries
          echo "Checking Docker service..."
          if check_service_with_retry "Docker" "sudo systemctl is-active docker >/dev/null"; then
            echo "Docker version: $(sudo docker --version)"
          fi

          # Check Nginx service with retries
          echo "Checking Nginx service..."
          if check_service_with_retry "Nginx" "sudo systemctl is-active nginx >/dev/null"; then
            echo "Nginx version: $(nginx -v 2>&1)"

            # Verify nginx routes configuration exists
            echo "Checking nginx routes configuration..."
            if [ -f /etc/nginx/routes/nginx-routes.json ]; then
              echo "‚úÖ nginx-routes.json found"
              if [ -f /etc/nginx/conf.d/dynamic-routes.conf ]; then
                echo "‚úÖ dynamic-routes.conf exists"
                # Test nginx configuration
                if sudo nginx -t >/dev/null 2>&1; then
                  echo "‚úÖ Nginx configuration is valid"
                else
                  echo "‚ö†Ô∏è Nginx configuration has issues, will be fixed"
                fi
              else
                echo "‚ö†Ô∏è dynamic-routes.conf missing, will be created"
              fi
            else
              echo "‚ö†Ô∏è nginx-routes.json missing - routes not configured"
            fi
          fi

          # Test nginx response with retries
          echo "Testing nginx response..."
          check_service_with_retry "Nginx HTTP response" 'curl -s --connect-timeout 5 -o /dev/null -w "%{http_code}" localhost | grep -q "200\|404"'

          # Check Docker registry with retries
          echo "Checking Docker registry..."
          if check_service_with_retry "Docker registry container" "docker ps | grep -q local-registry"; then
            echo "Testing Docker registry API..."
            if check_service_with_retry "Docker registry API" 'curl -s --connect-timeout 5 localhost:5000/v2/ | grep -q "{}"'; then
              echo "‚úÖ Docker registry is fully operational (localhost only)"
              echo "‚ÑπÔ∏è  Registry access: ssh -L 5000:localhost:5000 ec2-user@$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)"
            fi
          fi

          # Check Ollama with retries
          echo "Checking Ollama..."
          if check_service_with_retry "Ollama installation" "command -v ollama >/dev/null"; then
            echo "Ollama version: $(ollama --version 2>/dev/null || echo 'version unknown')"

            # Check if Ollama service is running
            if check_service_with_retry "Ollama service" "pgrep -f 'ollama serve' >/dev/null"; then
              echo "‚úÖ Ollama service is running"

              # Test Ollama API
              if check_service_with_retry "Ollama API" 'curl -s --connect-timeout 5 localhost:11434/api/tags >/dev/null'; then
                echo "‚úÖ Ollama API is responding"
                echo "‚ÑπÔ∏è  Ollama access: ssh -L 11434:localhost:11434 ec2-user@$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)"

                # List any installed models
                MODELS=$(ollama list 2>/dev/null | grep -v "NAME" | grep -v "^$" || echo "")
                if [ -n "$MODELS" ]; then
                  echo "‚úÖ Installed models:"
                  echo "$MODELS"
                else
                  echo "‚ÑπÔ∏è  No models installed yet - use GitHub Actions 'Manage Ollama Models' workflow"
                fi
              else
                echo "‚ö†Ô∏è Ollama service running but API not responding"
              fi
            else
              echo "‚ö†Ô∏è Ollama installed but service not running"
              echo "‚ÑπÔ∏è  Service will auto-start on next reboot or can be started manually"
            fi
          else
            echo "‚ùå Ollama not installed"
          fi

          # Final status summary
          echo ""
          echo "=== Service Status Summary ==="
          echo "Docker: $(sudo systemctl is-active docker)"
          echo "Nginx: $(sudo systemctl is-active nginx)"
          echo "Docker Registry: $(docker ps --filter name=local-registry --format 'table {{.Status}}' | tail -1)"
          echo "Ollama: $(if pgrep -f 'ollama serve' >/dev/null; then echo 'running'; else echo 'stopped'; fi)"
          echo "Setup completed at: $(cat /home/ec2-user/.setup-completed 2>/dev/null || echo 'Not found')"
        EOF

    - name: Output Instance Info
      if: github.event.inputs.action == 'apply'
      run: |
        cd terraform
        echo "## Infrastructure Outputs" >> $GITHUB_STEP_SUMMARY
        terraform output -json | jq -r 'to_entries[] | "- **\(.key)**: \(.value.value)"' >> $GITHUB_STEP_SUMMARY
