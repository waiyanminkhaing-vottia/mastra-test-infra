name: Setup HTTPS/SSL

on:
  workflow_dispatch:
    inputs:
      domain:
        description: 'Domain name for SSL certificate'
        required: true
        type: string
        default: 'test.dev-maestra.vottia.me'
      email:
        description: 'Email for SSL certificate notifications'
        required: true
        type: string
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - install
          - renew
          - status

jobs:
  setup-ssl:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Setup SSH connection
        id: setup-ssh
        run: |
          LIGHTSAIL_HOST="${{ github.event.inputs.domain }}"
          LIGHTSAIL_USER="ec2-user"

          echo "Connecting to: $LIGHTSAIL_HOST"

          # Setup SSH key from secrets
          mkdir -p ~/.ssh
          echo "${{ secrets.LIGHTSAIL_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Test SSH connection
          ssh-keyscan -H $LIGHTSAIL_HOST >> ~/.ssh/known_hosts 2>/dev/null

          if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no $LIGHTSAIL_USER@$LIGHTSAIL_HOST "echo 'SSH connection successful'" 2>/dev/null; then
            echo "‚úÖ SSH connection successful"
            echo "connected=true" >> $GITHUB_OUTPUT
            echo "instance_host=$LIGHTSAIL_HOST" >> $GITHUB_OUTPUT
            echo "instance_user=$LIGHTSAIL_USER" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to connect to server"
            echo "connected=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Install SSL Certificate
        if: github.event.inputs.action == 'install' && steps.setup-ssh.outputs.connected == 'true'
        run: |
          INSTANCE_HOST="${{ steps.setup-ssh.outputs.instance_host }}"
          INSTANCE_USER="${{ steps.setup-ssh.outputs.instance_user }}"
          DOMAIN="${{ github.event.inputs.domain }}"
          EMAIL="${{ github.event.inputs.email }}"

          echo "üì¶ Installing Certbot and obtaining SSL certificate..."

          ssh -o StrictHostKeyChecking=no $INSTANCE_USER@$INSTANCE_HOST << REMOTE_EOF
            # Install Certbot if not already installed
            if ! command -v certbot &> /dev/null; then
              echo "Installing Certbot..."
              sudo yum update -y
              sudo yum install -y certbot python3-certbot-nginx
            else
              echo "Certbot is already installed"
            fi

            # Check if certificate already exists
            if sudo test -d /etc/letsencrypt/live/$DOMAIN; then
              echo "‚ö†Ô∏è  Certificate for $DOMAIN already exists"
              echo "Use 'renew' action to renew the certificate"
              exit 0
            fi

            # Stop nginx temporarily to free up port 80
            sudo systemctl stop nginx

            # Obtain certificate using standalone mode
            echo "Obtaining SSL certificate for $DOMAIN..."
            sudo certbot certonly --standalone \
              --non-interactive \
              --agree-tos \
              --email $EMAIL \
              -d $DOMAIN

            if [ \$? -eq 0 ]; then
              echo "‚úÖ SSL certificate obtained successfully"

              # Setup auto-renewal using systemd timer (Amazon Linux 2023)
              echo "Setting up auto-renewal..."
              sudo systemctl enable certbot-renew.timer
              sudo systemctl start certbot-renew.timer

              # Verify timer is active
              if sudo systemctl is-active --quiet certbot-renew.timer; then
                echo "‚úÖ Auto-renewal timer enabled and active"
              else
                echo "‚ö†Ô∏è  Auto-renewal timer may not be active"
              fi

              # Regenerate nginx configuration with HTTPS enabled
              echo "Regenerating nginx configuration with HTTPS..."

              # Check if SSL certificates exist
              if sudo test -f /etc/letsencrypt/live/$DOMAIN/fullchain.pem; then
                USE_HTTPS="true"
                echo "‚úÖ SSL certificates found - enabling HTTPS"
              else
                USE_HTTPS="false"
                echo "‚ö†Ô∏è  SSL certificates not found - using HTTP only"
              fi

              # Generate nginx configuration
              USE_HTTPS=\$USE_HTTPS python3 << 'PYTHON_EOF'
          import json
          import os
          import sys

          # Read routes from JSON file
          try:
              with open('/etc/nginx/routes/nginx-routes.json', 'r') as f:
                  config = json.load(f)
          except:
              config = {'routes': []}

          # Check if SSL should be used (from environment)
          use_https = os.environ.get('USE_HTTPS', 'false') == 'true'
          print(f"HTTPS mode: {use_https}", file=sys.stderr)

          if use_https:
              # Generate HTTP to HTTPS redirect server block
              nginx_config = '''# HTTP server - redirect to HTTPS
          server {
              listen 80 default_server;
              server_name _;
              return 301 https://\$host\$request_uri;
          }

          # HTTPS server
          server {
              listen 443 ssl http2 default_server;
              server_name _;

              # SSL certificate paths (managed by Certbot)
              ssl_certificate /etc/letsencrypt/live/test.dev-maestra.vottia.me/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/test.dev-maestra.vottia.me/privkey.pem;
              ssl_trusted_certificate /etc/letsencrypt/live/test.dev-maestra.vottia.me/chain.pem;

              # SSL configuration
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
              ssl_prefer_server_ciphers off;
              ssl_session_cache shared:SSL:10m;
              ssl_session_timeout 10m;

              # Security headers
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;
              add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

              client_max_body_size 10M;

          '''
          else:
              # Generate HTTP-only server block
              nginx_config = '''# HTTP server (HTTPS not configured)
          server {
              listen 80 default_server;
              server_name _;

              # Security headers
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;

              client_max_body_size 10M;

          '''

          # Add routes from JSON
          root_route_exists = False
          for route in config.get('routes', []):
              if route['type'] == 'proxy':
                  path = route['path']
                  port = route['target_port']
                  route_type = route.get('route_type', 'normal')

                  # Handle root path specially
                  if path == '/' or path == '':
                      root_route_exists = True
                      nginx_config += f'''
              # Route: {route['name']} - root domain ({route_type})
              location / {{
                  proxy_pass http://127.0.0.1:{port}/;
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }}
          '''
                  else:
                      if route_type == 'nextjs':
                          # Next.js apps with basePath - preserve full path
                          nginx_config += f'''
              # Route: {route['name']} - Next.js with basePath
              location {path}/ {{
                  proxy_pass http://127.0.0.1:{port}{path}/;
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }}

              # Handle {path} without trailing slash
              location = {path} {{
                  proxy_pass http://127.0.0.1:{port}{path};
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }}
          '''
                      else:
                          # Normal apps - strip prefix
                          nginx_config += f'''
              # Route: {route['name']} - normal app (prefix stripped)
              location {path}/ {{
                  rewrite ^{path}(/.*)?$ \$1 break;
                  proxy_pass http://127.0.0.1:{port}/;
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }}

              # Handle {path} without trailing slash
              location = {path} {{
                  rewrite ^{path}$ / break;
                  proxy_pass http://127.0.0.1:{port};
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
              }}
          '''

          # Add health check endpoint (always available)
          nginx_config += '''
              # Health check endpoint
              location /health {
                  access_log off;
                  return 200 "OK\\n";
                  add_header Content-Type text/plain;
              }
          '''

          # Add default location only if no root route exists
          if not root_route_exists:
              nginx_config += '''
              # Default location
              location / {
                  return 200 "Mastra Infrastructure - Routes managed via GitHub Actions\\n";
                  add_header Content-Type text/plain;
              }
          '''

          nginx_config += '''
          }
          '''

          # Write nginx configuration
          with open('/tmp/dynamic-routes.conf', 'w') as f:
              f.write(nginx_config)
          PYTHON_EOF

              # Move generated config to nginx directory
              sudo mv /tmp/dynamic-routes.conf /etc/nginx/conf.d/dynamic-routes.conf

              # Test and reload nginx
              if sudo nginx -t; then
                echo "‚úÖ Nginx configuration is valid"
                sudo systemctl start nginx
                sudo systemctl reload nginx
                echo "‚úÖ Nginx reloaded with HTTPS enabled"
              else
                echo "‚ùå Nginx configuration test failed"
                sudo systemctl start nginx
                exit 1
              fi

              echo "‚úÖ SSL certificate installed and auto-renewal configured"
            else
              echo "‚ùå Failed to obtain SSL certificate"
              sudo systemctl start nginx
              exit 1
            fi
          REMOTE_EOF

      - name: Renew SSL Certificate
        if: github.event.inputs.action == 'renew' && steps.setup-ssh.outputs.connected == 'true'
        run: |
          INSTANCE_HOST="${{ steps.setup-ssh.outputs.instance_host }}"
          INSTANCE_USER="${{ steps.setup-ssh.outputs.instance_user }}"

          echo "üîÑ Renewing SSL certificate..."

          ssh -o StrictHostKeyChecking=no $INSTANCE_USER@$INSTANCE_HOST << 'REMOTE_EOF'
            # Renew certificate
            sudo certbot renew

            if [ $? -eq 0 ]; then
              echo "‚úÖ SSL certificate renewed successfully"
              sudo systemctl reload nginx
            else
              echo "‚ùå Failed to renew SSL certificate"
              exit 1
            fi
          REMOTE_EOF

      - name: Check SSL Status
        if: github.event.inputs.action == 'status' && steps.setup-ssh.outputs.connected == 'true'
        run: |
          INSTANCE_HOST="${{ steps.setup-ssh.outputs.instance_host }}"
          INSTANCE_USER="${{ steps.setup-ssh.outputs.instance_user }}"
          DOMAIN="${{ github.event.inputs.domain }}"

          echo "üìã Checking SSL certificate status..."

          ssh -o StrictHostKeyChecking=no $INSTANCE_USER@$INSTANCE_HOST << REMOTE_EOF
            if sudo test -d /etc/letsencrypt/live/$DOMAIN; then
              echo "‚úÖ SSL certificate exists for $DOMAIN"
              echo ""
              echo "Certificate details:"
              sudo certbot certificates -d $DOMAIN
            else
              echo "‚ùå No SSL certificate found for $DOMAIN"
              echo "Run the 'install' action to obtain a certificate"
            fi
          REMOTE_EOF

      - name: Summary
        if: always()
        run: |
          echo "## SSL Setup Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Action:** ${{ github.event.inputs.action }}" >> $GITHUB_STEP_SUMMARY
          echo "**Domain:** ${{ github.event.inputs.domain }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event.inputs.action }}" == "install" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "1. SSL certificate has been installed" >> $GITHUB_STEP_SUMMARY
            echo "2. Auto-renewal is configured (runs daily at 12:00)" >> $GITHUB_STEP_SUMMARY
            echo "3. Deploy your routes using the 'Manage Nginx Routes' workflow" >> $GITHUB_STEP_SUMMARY
            echo "4. Your site will automatically redirect HTTP to HTTPS" >> $GITHUB_STEP_SUMMARY
          fi
