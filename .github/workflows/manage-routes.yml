name: Manage Nginx Routes

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - add
          - edit
          - delete
          - list
      route_name:
        description: 'Route name (required for add/edit/delete)'
        required: false
        type: string
      route_path:
        description: 'Route path (e.g., /dashboard for Next.js, / for normal apps)'
        required: false
        type: string
      target_port:
        description: 'Target port (e.g., 3000)'
        required: false
        type: string
      route_type:
        description: 'Route type'
        required: false
        type: choice
        options:
          - nextjs
          - normal
        default: 'normal'

jobs:
  manage-routes:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate inputs
        run: |
          ACTION="${{ github.event.inputs.action }}"
          ROUTE_NAME="${{ github.event.inputs.route_name }}"
          ROUTE_PATH="${{ github.event.inputs.route_path }}"
          TARGET_PORT="${{ github.event.inputs.target_port }}"

          if [ "$ACTION" != "list" ]; then
            if [ -z "$ROUTE_NAME" ]; then
              echo "‚ùå Error: route_name is required for $ACTION action"
              exit 1
            fi
          fi

          if [ "$ACTION" = "add" ] || [ "$ACTION" = "edit" ]; then
            if [ -z "$TARGET_PORT" ]; then
              echo "‚ùå Error: target_port is required for $ACTION action"
              exit 1
            fi

            # Validate port is a number
            if ! [[ "$TARGET_PORT" =~ ^[0-9]+$ ]]; then
              echo "‚ùå Error: target_port must be a number"
              exit 1
            fi

            # Validate path format (allow empty string or must start with /)
            if [ -n "$ROUTE_PATH" ] && [[ ! "$ROUTE_PATH" =~ ^/ ]]; then
              echo "‚ùå Error: route_path must start with / or be empty for root"
              exit 1
            fi
          fi

          echo "‚úÖ Input validation passed"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: List routes
        if: github.event.inputs.action == 'list'
        run: |
          python3 << 'EOF'
          import json
          import os

          routes_file = 'nginx-routes.json'

          if not os.path.exists(routes_file):
              print("‚ö†Ô∏è  No routes configured yet")
              exit(0)

          with open(routes_file, 'r') as f:
              config = json.load(f)

          routes = config.get('routes', [])

          if not routes:
              print("‚ö†Ô∏è  No routes configured")
          else:
              print("üìã Current Routes:")
              print()
              for idx, route in enumerate(routes, 1):
                  print(f"{idx}. {route['name']}")
                  print(f"   Type: {route.get('route_type', 'normal')}")
                  print(f"   Path: {route['path']}")
                  print(f"   Target: localhost:{route['target_port']}")
                  print()
          EOF

      - name: Add route
        if: github.event.inputs.action == 'add'
        run: |
          python3 << 'EOF'
          import json
          import os

          route_name = "${{ github.event.inputs.route_name }}"
          route_path = "${{ github.event.inputs.route_path }}"
          target_port = "${{ github.event.inputs.target_port }}"
          route_type = "${{ github.event.inputs.route_type }}"

          routes_file = 'nginx-routes.json'

          # Load existing routes
          if os.path.exists(routes_file):
              with open(routes_file, 'r') as f:
                  config = json.load(f)
          else:
              config = {'routes': []}

          # Check if route already exists
          for route in config['routes']:
              if route['name'] == route_name:
                  print(f"‚ùå Error: Route '{route_name}' already exists")
                  exit(1)
              if route['path'] == route_path:
                  print(f"‚ùå Error: Path '{route_path}' is already used by route '{route['name']}'")
                  exit(1)

          # Add new route
          new_route = {
              'name': route_name,
              'type': 'proxy',
              'route_type': route_type,
              'path': route_path,
              'target_port': int(target_port)
          }

          config['routes'].append(new_route)

          # Save updated routes
          with open(routes_file, 'w') as f:
              json.dump(config, f, indent=2)

          print(f"‚úÖ Added route '{route_name}' successfully")
          print(f"   Type: {route_type}")
          print(f"   Path: {route_path}")
          print(f"   Target: localhost:{target_port}")
          EOF

      - name: Edit route
        if: github.event.inputs.action == 'edit'
        run: |
          python3 << 'EOF'
          import json
          import os

          route_name = "${{ github.event.inputs.route_name }}"
          route_path = "${{ github.event.inputs.route_path }}"
          target_port = "${{ github.event.inputs.target_port }}"
          route_type = "${{ github.event.inputs.route_type }}"

          routes_file = 'nginx-routes.json'

          if not os.path.exists(routes_file):
              print("‚ùå Error: No routes file found")
              exit(1)

          with open(routes_file, 'r') as f:
              config = json.load(f)

          # Find and update route
          found = False
          for route in config['routes']:
              if route['name'] == route_name:
                  found = True
                  old_path = route['path']
                  old_port = route['target_port']
                  old_type = route.get('route_type', 'normal')

                  route['path'] = route_path
                  route['target_port'] = int(target_port)
                  route['route_type'] = route_type

                  print(f"‚úÖ Updated route '{route_name}'")
                  print(f"   Type: {old_type} ‚Üí {route_type}")
                  print(f"   Path: {old_path} ‚Üí {route_path}")
                  print(f"   Port: {old_port} ‚Üí {target_port}")
                  break

          if not found:
              print(f"‚ùå Error: Route '{route_name}' not found")
              exit(1)

          # Save updated routes
          with open(routes_file, 'w') as f:
              json.dump(config, f, indent=2)
          EOF

      - name: Delete route
        if: github.event.inputs.action == 'delete'
        run: |
          python3 << 'EOF'
          import json
          import os

          route_name = "${{ github.event.inputs.route_name }}"

          routes_file = 'nginx-routes.json'

          if not os.path.exists(routes_file):
              print("‚ùå Error: No routes file found")
              exit(1)

          with open(routes_file, 'r') as f:
              config = json.load(f)

          # Find and remove route
          initial_count = len(config['routes'])
          config['routes'] = [r for r in config['routes'] if r['name'] != route_name]

          if len(config['routes']) == initial_count:
              print(f"‚ùå Error: Route '{route_name}' not found")
              exit(1)

          # Save updated routes
          with open(routes_file, 'w') as f:
              json.dump(config, f, indent=2)

          print(f"‚úÖ Deleted route '{route_name}'")
          EOF

      - name: Commit changes
        if: github.event.inputs.action != 'list'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add nginx-routes.json

          if git diff --staged --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          ACTION="${{ github.event.inputs.action }}"
          ROUTE_NAME="${{ github.event.inputs.route_name }}"

          git commit -m "${ACTION^} nginx route: ${ROUTE_NAME}"
          git push

      - name: Setup SSH connection
        if: github.event.inputs.action != 'list'
        id: setup-ssh
        run: |
          # Use the known domain name
          LIGHTSAIL_HOST="test.dev-maestra.vottia.me"
          LIGHTSAIL_USER="ec2-user"

          echo "Connecting to: $LIGHTSAIL_HOST"

          # Setup SSH key from secrets
          mkdir -p ~/.ssh
          echo "${{ secrets.LIGHTSAIL_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Test SSH connection
          ssh-keyscan -H $LIGHTSAIL_HOST >> ~/.ssh/known_hosts 2>/dev/null

          if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no $LIGHTSAIL_USER@$LIGHTSAIL_HOST "echo 'SSH connection successful'" 2>/dev/null; then
            echo "‚úÖ SSH connection successful"
            echo "deployed=true" >> $GITHUB_OUTPUT
            echo "instance_host=$LIGHTSAIL_HOST" >> $GITHUB_OUTPUT
            echo "instance_user=$LIGHTSAIL_USER" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to connect to server"
            echo "deployed=false" >> $GITHUB_OUTPUT
          fi

      - name: Deploy routes to server
        if: github.event.inputs.action != 'list' && steps.setup-ssh.outputs.deployed == 'true'
        run: |
          INSTANCE_HOST="${{ steps.setup-ssh.outputs.instance_host }}"
          INSTANCE_USER="${{ steps.setup-ssh.outputs.instance_user }}"

          echo "üì§ Deploying routes to server..."

          # Copy routes file to server
          scp -o StrictHostKeyChecking=no nginx-routes.json $INSTANCE_USER@$INSTANCE_HOST:/tmp/

          # Deploy routes and reload nginx
          ssh -o StrictHostKeyChecking=no $INSTANCE_USER@$INSTANCE_HOST << 'REMOTE_EOF'
            # Check if SSL certificates exist
            DOMAIN="test.dev-maestra.vottia.me"
            SSL_CERT_PATH="/etc/letsencrypt/live/$DOMAIN/fullchain.pem"

            if sudo test -f "$SSL_CERT_PATH"; then
              echo "‚úÖ SSL certificate found"
              USE_HTTPS=true
            else
              echo "‚ö†Ô∏è  SSL certificate not found - will use HTTP only"
              echo "Run the 'Setup HTTPS/SSL' workflow to install certificates"
              USE_HTTPS=false
            fi

            # Move routes file
            sudo mkdir -p /etc/nginx/routes
            sudo mv /tmp/nginx-routes.json /etc/nginx/routes/

            # Check if SSL certificates exist
            if sudo test -f /etc/letsencrypt/live/test.dev-maestra.vottia.me/fullchain.pem; then
              USE_HTTPS="true"
              echo "‚úÖ SSL certificates found - enabling HTTPS"
            else
              USE_HTTPS="false"
              echo "‚ö†Ô∏è  SSL certificates not found - using HTTP only"
            fi

            # Generate nginx configuration
            USE_HTTPS=$USE_HTTPS python3 << 'PYTHON_EOF'
          import json
          import os
          import sys

          # Read routes from JSON file
          try:
              with open('/etc/nginx/routes/nginx-routes.json', 'r') as f:
                  config = json.load(f)
          except:
              config = {'routes': []}

          # Check if SSL should be used (from environment)
          use_https = os.environ.get('USE_HTTPS', 'false') == 'true'
          print(f"HTTPS mode: {use_https}", file=sys.stderr)

          if use_https:
              # Generate HTTP to HTTPS redirect server block
              nginx_config = '''# HTTP server - redirect to HTTPS
          server {
              listen 80 default_server;
              server_name _;
              return 301 https://$host$request_uri;
          }

          # HTTPS server
          server {
              listen 443 ssl http2 default_server;
              server_name _;

              # SSL certificate paths (managed by Certbot)
              ssl_certificate /etc/letsencrypt/live/test.dev-maestra.vottia.me/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/test.dev-maestra.vottia.me/privkey.pem;
              ssl_trusted_certificate /etc/letsencrypt/live/test.dev-maestra.vottia.me/chain.pem;

              # SSL configuration
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
              ssl_prefer_server_ciphers off;
              ssl_session_cache shared:SSL:10m;
              ssl_session_timeout 10m;

              # Security headers
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;
              add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

              client_max_body_size 10M;

          '''
          else:
              # Generate HTTP-only server block
              nginx_config = '''# HTTP server (HTTPS not configured)
          server {
              listen 80 default_server;
              server_name _;

              # Security headers
              add_header X-Frame-Options "SAMEORIGIN" always;
              add_header X-Content-Type-Options "nosniff" always;
              add_header X-XSS-Protection "1; mode=block" always;

              client_max_body_size 10M;

          '''

          # Add routes from JSON
          root_route_exists = False
          for route in config.get('routes', []):
              if route['type'] == 'proxy':
                  path = route['path']
                  port = route['target_port']
                  route_type = route.get('route_type', 'normal')

                  # Handle root path specially
                  if path == '/' or path == '':
                      root_route_exists = True
                      nginx_config += f'''
              # Route: {route['name']} - root domain ({route_type})
              location / {{
                  proxy_pass http://127.0.0.1:{port}/;
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }}
          '''
                  else:
                      if route_type == 'nextjs':
                          # Next.js apps with basePath - preserve full path
                          nginx_config += f'''
              # Route: {route['name']} - Next.js with basePath
              location {path}/ {{
                  proxy_pass http://127.0.0.1:{port}{path}/;
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }}

              # Handle {path} without trailing slash
              location = {path} {{
                  proxy_pass http://127.0.0.1:{port}{path};
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }}
          '''
                      else:
                          # Normal apps - strip prefix
                          nginx_config += f'''
              # Route: {route['name']} - normal app (prefix stripped)
              location {path}/ {{
                  rewrite ^{path}(/.*)?$ $1 break;
                  proxy_pass http://127.0.0.1:{port}/;
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }}

              # Handle {path} without trailing slash
              location = {path} {{
                  rewrite ^{path}$ / break;
                  proxy_pass http://127.0.0.1:{port};
                  proxy_read_timeout 120s;
                  proxy_connect_timeout 90s;
                  proxy_send_timeout 90s;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
              }}
          '''

          # Add health check endpoint (always available)
          nginx_config += '''
              # Health check endpoint
              location /health {
                  access_log off;
                  return 200 "OK\\n";
                  add_header Content-Type text/plain;
              }
          '''

          # Add default location only if no root route exists
          if not root_route_exists:
              nginx_config += '''
              # Default location
              location / {
                  return 200 "Mastra Infrastructure - Routes managed via GitHub Actions\\n";
                  add_header Content-Type text/plain;
              }
          '''

          nginx_config += '''
          }
          '''

          # Write nginx configuration
          with open('/tmp/dynamic-routes.conf', 'w') as f:
              f.write(nginx_config)
          PYTHON_EOF

            # Move generated config to nginx directory
            sudo mv /tmp/dynamic-routes.conf /etc/nginx/conf.d/dynamic-routes.conf

            # Test nginx configuration
            if sudo nginx -t; then
              echo "‚úÖ Nginx configuration is valid"
              sudo systemctl reload nginx
              echo "‚úÖ Nginx reloaded successfully"
            else
              echo "‚ùå Nginx configuration test failed"
              exit 1
            fi
          REMOTE_EOF

          echo "‚úÖ Routes deployed and nginx reloaded"

      - name: Summary
        if: always()
        run: |
          echo "## Route Management Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Action:** ${{ github.event.inputs.action }}" >> $GITHUB_STEP_SUMMARY

          if [ "${{ github.event.inputs.action }}" != "list" ]; then
            echo "**Route Name:** ${{ github.event.inputs.route_name }}" >> $GITHUB_STEP_SUMMARY

            if [ "${{ github.event.inputs.action }}" != "delete" ]; then
              echo "**Route Type:** ${{ github.event.inputs.route_type }}" >> $GITHUB_STEP_SUMMARY
              echo "**Path:** ${{ github.event.inputs.route_path }}" >> $GITHUB_STEP_SUMMARY
              echo "**Target Port:** ${{ github.event.inputs.target_port }}" >> $GITHUB_STEP_SUMMARY
            fi
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pattern Explanations" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next.js Apps:** \`localhost:\${port}/path\` - Full path preserved for basePath support" >> $GITHUB_STEP_SUMMARY
          echo "**Normal Apps:** \`localhost:\${port}\` - Path prefix stripped, clean routing" >> $GITHUB_STEP_SUMMARY